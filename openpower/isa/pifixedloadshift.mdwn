<!-- This defines DRAFT instructions that are to be proposed for SV -->

<!-- This defines instructions that load from RAM to a register -->
<!-- Effective Address is always RA, and the usual EA is stored late in RA -->

<!-- Note that these pages also define equivalent store instructions, -->
<!-- these are described in pifixedstoreshift.mdwn -->
<!-- https://bugs.libre-soc.org/show_bug.cgi?id=1055 -->
<!-- https://libre-soc.org/openpower/sv/rfc/ls004/ -->




# Load Byte and Zero with Post-Update Indexed

X-Form

* lbzupsx RT,RA,RB,SH

Pseudo-code:

    EA <- (RA)<<(SH+1)
    RT <- ([0] * (XLEN-8)) || MEM(EA, 1)
    RA <- (RA) + (RB)

Description:

    Let the effective address (EA) be the contents of
    register RA shifted by (SH+1).

    The byte in storage addressed by EA is loaded into RT[56:63]. 
    RT[0:55] are set to 0.

    The sum (RA) + (RB) is placed into register RA.

    If RA=0 or RA=RT, the instruction form is invalid.

Special Registers Altered:

    None

# Load Halfword and Zero with Post-Update Indexed

X-Form

* lhzupsx RT,RA,RB,SH

Pseudo-code:

    EA <- (RA)<<(SH+1)
    RT <- ([0] * (XLEN-16)) || MEM(EA, 2)
    RA <- (RA) + (RB)

Description:

    Let the effective address (EA) be the contents of
    register RA shifted by (SH+1).

    The halfword in storage addressed by EA is loaded into RT[48:63]. 
    RT[0:47] are set to 0.

    The sum (RA) + (RB) is placed into register RA.

    If RA=0 or RA=RT, the instruction form is invalid.

Special Registers Altered:

    None

# Load Halfword Algebraic with Post-Update Indexed

X-Form

* lhaupsx RT,RA,RB,SH

Pseudo-code:

    EA <- (RA)<<(SH+1)
    RT <- EXTS(MEM(EA, 2))
    RA <- (RA) + (RB)

Description:

    Let the effective address (EA) be the contents of
    register RA shifted by (SH+1).

    The halfword in storage addressed by EA is loaded into RT[48:63].
    RT[0:47] are filled with a copy of bit 0 of the loaded halfword.

    The sum (RA) + (RB) is placed into register RA.

    If RA=0 or RA=RT, the instruction form is invalid.

Special Registers Altered:

    None

# Load Word and Zero with Post-Update Indexed

X-Form

* lwzupsx RT,RA,RB,SH

Pseudo-code:

    EA <- (RA)<<(SH+1)
    RT <- [0] * 32 || MEM(EA, 4)
    RA <- (RA) + (RB)

Description:

    Let the effective address (EA) be the contents of
    register RA shifted by (SH+1).

    The halfword in storage addressed by EA is loaded into RT[48:63].
    RT[0:47] are filled with a copy of bit 0 of the loaded halfword.

    The sum (RA) + (RB) is placed into register RA.

    If RA=0 or RA=RT, the instruction form is invalid.

Special Registers Altered:

    None

# Load Word Algebraic with Post-Update Indexed

X-Form

* lwaupsx RT,RA,RB.SH

Pseudo-code:

    EA <- (RA)<<(SH+1)
    RT <- EXTS(MEM(EA, 4))
    RA <- (RA) + (RB)

Description:

    Let the effective address (EA) be the contents of
    register RA shifted by (SH+1).

    The word in storage addressed by EA is loaded into RT[32:63].
    RT[0:31] are filled with a copy of bit 0 of the loaded word.

    The sum (RA) + (RB) is placed into register RA.

    If RA=0 or RA=RT, the instruction form is invalid.

Special Registers Altered:

    None

# Load Doubleword with Post-Update Indexed

X-Form

* ldupsx RT,RA,RB,SH

Pseudo-code:

    EA <- (RA)<<(SH+1)
    RT <- MEM(EA, 8)
    RA <- (RA) + (RB)

Description:

    Let the effective address (EA) be the contents of
    register RA shifted by (SH+1).

    The doubleword in storage addressed by EA is loaded into RT.

    The sum (RA) + (RB) is placed into register RA.

    If RA=0 or RA=RT, the instruction form is invalid.

Special Registers Altered:

    None

