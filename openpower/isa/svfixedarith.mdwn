# [DRAFT] Multiply and Add Extended Doubleword Unsigned

VA-Form

* maddedu RT,RA,RB,RC

Pseudo-code:

    <!-- SVP64: RA,RB,RC,RT have EXTRA2, RS as below
    <!-- bit 8 of EXTRA is set  : RS.[s|v]=RT.[s|v]+MAXVL
    <!-- bit 8 of EXTRA is clear: RS.[s|v]=RC.[s|v]
    prod[0:2*XLEN-1] <- (RA) * (RB)
    sum[0:2*XLEN-1] <- ([0] * XLEN || (RC)) + prod
    RT <- sum[XLEN:2*XLEN-1]
    RS <- sum[0:XLEN-1]

Special Registers Altered:

    None

# [DRAFT] Divide/Modulo Double-width Doubleword Unsigned

VA-Form

* divmod2du   RT,RA,RB,RC

Pseudo-code:

    <!-- SVP64: RA,RB,RC,RT have EXTRA2, RS as below
    <!-- bit 8 of EXTRA is set  : RS.[s|v]=RT.[s|v]+MAXVL
    <!-- bit 8 of EXTRA is clear: RS.[s|v]=RC.[s|v]
    if ((RC) <u (RB)) & ((RB) != [0]*XLEN) then
        dividend[0:(XLEN*2)-1] <- (RC) || (RA)
        divisor[0:(XLEN*2)-1] <- [0]*XLEN || (RB)
        result <- dividend / divisor
        modulo <- dividend % divisor
        RT <- result[XLEN:(XLEN*2)-1]
        RS <- modulo[XLEN:(XLEN*2)-1]
        overflow <- 0
    else
        overflow <- 1
        RT <- [1]*XLEN
        RS <- [0]*XLEN

Special Registers Altered:

    None

# [DRAFT] Double-width Shift Left Doubleword

VA2-Form

* dsld    RT,RA,RB,RC  (Rc=0)
* dsld.   RT,RA,RB,RC  (Rc=1)

Pseudo-code:

    n <- (RB)[58:63]
    v <- ROTL64((RA), n)
    mask <- MASK(0, 63-n)
    RT <- (v[0:63] & mask) | ((RC) & ¬mask)
    RS <- v[0:63] & ¬mask
    overflow <- 0
    if RS != [0]*64 then
        overflow <- 1

Special Registers Altered:

    CR0                    (if Rc=1)

# [DRAFT] Double-width Shift Right Doubleword

VA2-Form

* dsrd    RT,RA,RB,RC  (Rc=0)
* dsrd.   RT,RA,RB,RC  (Rc=1)

Pseudo-code:

    n <- (RB)[58:63]
    v <- ROTL64((RA), 64-n)
    mask <- MASK(n, 63)
    RT <- (v[0:63] & mask) | ((RC) & ¬mask)
    RS <- v[0:63] & ¬mask
    overflow <- 0
    if RS != [0]*64 then
        overflow <- 1

Special Registers Altered:

    CR0                    (if Rc=1)
