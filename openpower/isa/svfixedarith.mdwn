# [DRAFT] Multiply and Add Extended Doubleword

VA-Form

* maddedu RT,RA,RB,RC

Pseudo-code:

    <!-- SVP64: RA,RB,RC,RT have EXTRA2, RS as below
    <!-- bit 8 of EXTRA is set  : RS.[s|v]=RT.[s|v]+MAXVL
    <!-- bit 8 of EXTRA is clear: RS.[s|v]=RC.[s|v]
    prod[0:127] <- (RA) * (RB)
    sum[0:127] <- ([0] * 64 || (RC)) + prod
    RT <- sum[64:127]
    RS <- sum[0:63]

Special Registers Altered:

    None

# [DRAFT] Divide/Modulo Double-width Doubleword Unsigned

VA-Form

* divmod2du   RT,RA,RB,RC

Pseudo-code:

    <!-- SVP64: RA,RB,RC,RT have EXTRA2, RS as below
    <!-- bit 8 of EXTRA is set  : RS.[s|v]=RT.[s|v]+MAXVL
    <!-- bit 8 of EXTRA is clear: RS.[s|v]=RC.[s|v]
    if ((RC) <u (RB)) & ((RB) != [0]*XLEN) then
        dividend[0:(XLEN*2)-1] <- (RC) || (RA)
        divisor[0:(XLEN*2)-1] <- [0]*XLEN || (RB)
        result <- dividend / divisor
        modulo <- dividend % divisor
        RT <- result[XLEN:(XLEN*2)-1]
        RS <- modulo[XLEN:(XLEN*2)-1]
        overflow <- 0
    else
        overflow <- 1
        RT <- [1]*XLEN
        RS <- [0]*XLEN

Special Registers Altered:

    None

# [DRAFT] Double-width Shift Left Doubleword

VA2-Form

* dsld    RT,RA,RB,RC  (Rc=0)
* dsld.   RT,RA,RB,RC  (Rc=1)

Pseudo-code:

    n <- (RB)[58:63]
    v <- ROTL128([0]*64 || (RA), n)
    RT <- v[64:127] | ((RC) & MASK(n, 63))
    RS <- v[0:63]

Special Registers Altered:

    CR0                    (if Rc=1)

# [DRAFT] Double-width Shift Right Doubleword

VA2-Form

* dsrd    RT,RA,RB,RC  (Rc=0)
* dsrd.   RT,RA,RB,RC  (Rc=1)

Pseudo-code:

    hi <- (RC)
    lo <- (RA)
    sh <- (RB)
    n <- sh[58:63]
    mask[0:63] <- MASK(0, 63 - n)
    v[0:63] <- (hi & Â¬mask) | (lo & mask)
    RT <- ROTL64(v, 64 - n)

Special Registers Altered:

    CR0                    (if Rc=1)
