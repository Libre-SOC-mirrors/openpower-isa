<!-- DRAFT Instructions for PowerISA Version 3.0 B Book 1 -->
<!-- https://libre-soc.org/openpower/sv/bitmanip/ -->
<!-- https://libre-soc.org/openpower/sv/av_opcodes/ -->

# DRAFT Minimum/Maximum (Rc=1)

MM-Form

* minmax. RT,RA,RB,MMM (Rc=1)

Pseudo-code:

    a <- (RA|0)
    b <- (RB)
    if MMM[0] then  # word mode
        # shift left by XLEN/2 to make the dword comparison
        # do word comparison of the original inputs
        a <- a[XLEN/2:XLEN-1] || [0] * XLEN/2
        b <- b[XLEN/2:XLEN-1] || [0] * XLEN/2
    if MMM[1] then  # signed mode
        # invert sign bits to make the unsigned comparison
        # do signed comparison of the original inputs
        a[0] <- ¬a[0]
        b[0] <- ¬b[0]
    # if Rc = 1 then store the result of comparing a and b to CR0
    if Rc = 1 then
        if a <u b then
            CR0 <- 0b100 || XER[SO]
        if a = b then
            CR0 <- 0b001 || XER[SO]
        if a >u b then
            CR0 <- 0b010 || XER[SO]
    if MMM[2] then  # max mode
        # swap a and b to make the less than comparison do
        # greater than comparison of the original inputs
        t <- a
        a <- b
        b <- t
    # store the entire selected source (even in word mode)
    # if Rc = 1 then store the result of comparing a and b to CR0
    if a <u b then RT <- (RA|0)
    else           RT <- (RB)

Special Registers Altered:

    CR0                     (if Rc=1)

# DRAFT Minimum/Maximum

MM-Form

* minmax RT,RA,RB,MMM (Rc=0)

Pseudo-code:

    a <- (RA|0)
    b <- (RB)
    if MMM[0] then  # word mode
        # shift left by XLEN/2 to make the dword comparison
        # do word comparison of the original inputs
        a <- a[XLEN/2:XLEN-1] || [0] * XLEN/2
        b <- b[XLEN/2:XLEN-1] || [0] * XLEN/2
    if MMM[1] then  # signed mode
        # invert sign bits to make the unsigned comparison
        # do signed comparison of the original inputs
        a[0] <- ¬a[0]
        b[0] <- ¬b[0]
    # if Rc = 1 then store the result of comparing a and b to CR0
    # if Rc = 1 then
    #     if a <u b then
    #         CR0 <- 0b100 || XER[SO]
    #     if a = b then
    #         CR0 <- 0b001 || XER[SO]
    #     if a >u b then
    #         CR0 <- 0b010 || XER[SO]
    if MMM[2] then  # max mode
        # swap a and b to make the less than comparison do
        # greater than comparison of the original inputs
        t <- a
        a <- b
        b <- t
    # store the entire selected source (even in word mode)
    if a <u b then RT <- (RA|0)
    else           RT <- (RB)

Special Registers Altered:

    None

# DRAFT Average Add

X-Form

* avgadd  RT,RA,RB (Rc=0)
* avgadd. RT,RA,RB (Rc=1)

Pseudo-code:

    a <- [0] * (XLEN+1)
    b <- [0] * (XLEN+1)
    a[1:XLEN] <- (RA)
    b[1:XLEN] <- (RB)
    r <- (a + b + 1)
    RT <- r[0:XLEN-1]

Special Registers Altered:

    CR0                     (if Rc=1)

# DRAFT Absolute Signed Difference

X-Form

* absds  RT,RA,RB (Rc=0)
* absds. RT,RA,RB (Rc=1)

Pseudo-code:

    if (RA) < (RB) then RT <- ¬(RA) + (RB) + 1
    else                RT <- ¬(RB) + (RA) + 1

Special Registers Altered:

    CR0                     (if Rc=1)

# DRAFT Absolute Unsigned Difference

X-Form

* absdu  RT,RA,RB (Rc=0)
* absdu. RT,RA,RB (Rc=1)

Pseudo-code:

    if (RA) <u (RB) then RT <- ¬(RA) + (RB) + 1
    else                RT <- ¬(RB) + (RA) + 1

Special Registers Altered:

    CR0                     (if Rc=1)

# DRAFT Absolute Accumulate Unsigned Difference

X-Form

* absdacu  RT,RA,RB (Rc=0)
* absdacu. RT,RA,RB (Rc=1)

Pseudo-code:

    if (RA) <u (RB) then r <- ¬(RA) + (RB) + 1
    else                 r <- ¬(RB) + (RA) + 1
    RT <- (RT) + r

Special Registers Altered:

    CR0                     (if Rc=1)

# DRAFT Absolute Accumulate Signed Difference

X-Form

* absdacs  RT,RA,RB (Rc=0)
* absdacs. RT,RA,RB (Rc=1)

Pseudo-code:

    if (RA) < (RB) then r <- ¬(RA) + (RB) + 1
    else                r <- ¬(RB) + (RA) + 1
    RT <- (RT) + r

Special Registers Altered:

    CR0                     (if Rc=1)

# Carry Propagate

X-Form

* cprop RT,RA,RB (Rc=0)
* cprop. RT,RA,RB (Rc=1)

Pseudo-code:

    P <- (RA)
    G <- (RB)
    temp <- (P|G)+G
    RT <- temp^P

Special Registers Altered:

    CR0                    (if Rc=1)

# DRAFT Bitmanip Masked

BM2-Form

* bmask  RT,RA,RB,bm,L

Pseudo-code:

    if _RB = 0 then mask <- [1] * XLEN
    else mask <- (RB)
    ra <- (RA) & mask
    a1 <- ra
    if bm[4] = 0 then a1 <- ¬ra
    mode2 <- bm[2:3]
    if mode2 = 0 then a2 <- (¬ra)+1
    if mode2 = 1 then a2 <- ra-1
    if mode2 = 2 then a2 <- ra+1
    if mode2 = 3 then a2 <- ¬(ra+1)
    a1 <- a1 & mask
    a2 <- a2 & mask
    # select operator
    mode3 <- bm[0:1]
    if mode3 = 0 then result <- a1 | a2
    if mode3 = 1 then result <- a1 & a2
    if mode3 = 2 then result <- a1 ^ a2
    if mode3 = 3 then result <- undefined([0]*XLEN)
    result <- result & mask
    # optionally restore masked-out bits
    if L = 1 then
        result <- result | (RA & ¬mask)
    RT <- result

Special Registers Altered:

    None

# Load Floating-Point Immediate

DX-Form

* fmvis FRS,D

Pseudo-code:

    bf16 <- d0 || d1 || d2
    fp32 <- bf16 || [0]*16
    FRS  <- DOUBLE(fp32)

Special Registers Altered:

    None

# Float Replace Lower-Half Single, Immediate

DX-Form

* fishmv FRS,D

Pseudo-code:

    fp32 <- SINGLE((FRS))
    fp32[16:31] <- d0 || d1 || d2
    FRS <- DOUBLE(fp32)

Special Registers Altered:

    None
