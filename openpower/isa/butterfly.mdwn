<!-- SVP64 Butterfly DCT Instructions here described are based on -->

<!-- PLEASE NOTE THESE ARE UNAPPROVED AND DRAFT, NOT SUBMITTED TO OPF ISA WG -->

# [DRAFT] Integer Butterfly Multiply Add/Sub FFT/DCT

A-Form

* maddsubrs  RT,RA,SH,RB

Pseudo-code:

    n <- SH
    sum <- (RT) + (RA)
    diff <- (RT) - (RA)
    prod1 <- MULS(RB, sum)
    prod1_lo <- prod1[XLEN:(XLEN*2)-1]
    prod2 <- MULS(RB, diff)
    prod2_lo <- prod2[XLEN:(XLEN*2)-1]
    if n = 0 then
        RT <- prod1_lo
        RS <- prod2_lo
    else
        round <- [0]*XLEN
        round[XLEN -n] <- 1
        prod1_lo <- prod1_lo + round
        prod2_lo <- prod2_lo + round
        m <- MASK(n, (XLEN-1))
        res1 <- ROTL64(prod1_lo, XLEN-n) & m
        res2 <- ROTL64(prod2_lo, XLEN-n) & m
        signbit1 <- prod1_lo[0]
        signbit2 <- prod2_lo[0]
        smask1 <- ([signbit1]*XLEN) & ¬m
        smask2 <- ([signbit2]*XLEN) & ¬m
        RT <- (res1 | smask1)
        RS <- (res2 | smask2)

Special Registers Altered:

    None

# [DRAFT] Integer Butterfly Multiply Add and Accumulate FFT/DCT

A-Form

* maddrs  RT,RA,SH,RB

Pseudo-code:

    n <- SH
    prod <- MULS(RB, RA)
    prod_lo <- prod[XLEN:(XLEN*2)-1]
    if n = 0 then
        RT <- (RT) + prod_lo
        RS <- (RS) - prod_lo
    else
        res1 <- (RT) + prod_lo
        res2 <- (RS) - prod_lo
        round <- [0]*XLEN
        round[XLEN -n] <- 1
        res1 <- res1 + round
        res2 <- res2 + round
        signbit1 <- res1[0]
        signbit2 <- res2[0]
        m <- MASK(n, (XLEN-1))
        res1 <- ROTL64(res1, XLEN-n) & m
        res2 <- ROTL64(res2, XLEN-n) & m
        smask1 <- ([signbit1]*XLEN) & ¬m
        smask2 <- ([signbit2]*XLEN) & ¬m
        RT <- (res1 | smask1)
        RS <- (res2 | smask2)

Special Registers Altered:

    None
