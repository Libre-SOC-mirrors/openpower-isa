<!-- SVP64 Butterfly DCT Instructions here described are based on -->

<!-- PLEASE NOTE THESE ARE UNAPPROVED AND DRAFT, NOT SUBMITTED TO OPF ISA WG -->

# [DRAFT] Integer Butterfly Multiply Add/Sub FFT/DCT

A-Form

* maddsubrs  RT,RA,SH,RB

Pseudo-code:

    n <- SH
    sum <- (RT) + (RA)
    diff <- (RT) - (RA)
    prod1 <- MULS(RB, sum)
    prod2 <- MULS(RB, diff)
    if n = 0 then
        prod1_lo <- prod1[XLEN:(XLEN*2)-1]
        prod2_lo <- prod2[XLEN:(XLEN*2)-1]
        RT <- prod1_lo
        RS <- prod2_lo
    else
        if XLEN = 64 then
            prod1_lo <- prod1[XLEN:(XLEN*2)-1]
            prod2_lo <- prod2[XLEN:(XLEN*2)-1]
            round <- [0]*XLEN
            round[XLEN -n] <- 1
            prod1_lo <- prod1_lo + round
            prod2_lo <- prod2_lo + round
            m <- MASK(n, (XLEN-1))
            res1 <- ROTL64(prod1_lo, XLEN-n) & m
            res2 <- ROTL64(prod2_lo, XLEN-n) & m
            signbit1 <- prod1_lo[0]
            signbit2 <- prod2_lo[0]
            smask1 <- ([signbit1]*XLEN) & ¬m
            smask2 <- ([signbit2]*XLEN) & ¬m
            RT <- (res1 | smask1)
            RS <- (res2 | smask2)
        else
            round <- [0]*(XLEN*2)
            round[XLEN*2 -n] <- 1
            prod1 <- prod1 + round
            prod2 <- prod2 + round
            m <- MASK(XLEN-n, XLEN-1)
            res1 <- prod1[XLEN-n:XLEN*2 -n -1]
            res2 <- prod2[XLEN-n:XLEN*2 -n -1]
            signbit1 <- prod1[0]
            signbit2 <- prod2[0]
            smask1 <- ([signbit1]*XLEN) & ¬m
            smask2 <- ([signbit2]*XLEN) & ¬m
            RT <- (res1 | smask1)
            RS <- (res2 | smask2)

Special Registers Altered:

    None

# [DRAFT] Integer Butterfly Multiply Add and Accumulate FFT/DCT

A-Form

* maddrs  RT,RA,SH,RB

Pseudo-code:

    n <- SH
    prod <- MULS(RB, RA)
    if n = 0 then
        prod_lo <- prod[XLEN:(XLEN*2)-1]
        RT <- (RT) + prod_lo
        RS <- (RS) - prod_lo
    else
        if XLEN = 64 then
            prod_lo <- prod[XLEN:(XLEN*2)-1]
            res1 <- (RT) + prod_lo
            res2 <- (RS) - prod_lo
            round <- [0]*XLEN
            round[XLEN -n] <- 1
            res1 <- res1 + round
            res2 <- res2 + round
            signbit1 <- res1[0]
            signbit2 <- res2[0]
            m <- MASK(n, (XLEN-1))
            res1 <- ROTL64(res1, XLEN-n) & m
            res2 <- ROTL64(res2, XLEN-n) & m
            smask1 <- ([signbit1]*XLEN) & ¬m
            smask2 <- ([signbit2]*XLEN) & ¬m
            RT <- (res1 | smask1)
            RS <- (res2 | smask2)
        else
            res1 <- (RT) + prod
            res2 <- (RS) - prod
            round <- [0]*XLEN*2
            round[XLEN*2 -n] <- 1
            res1 <- res1 + round
            res2 <- res2 + round
            signbit1 <- res1[0]
            signbit2 <- res2[0]
            m <- MASK(XLEN-n, (XLEN-1))
            res1 <- prod1[XLEN-n:XLEN*2 -n -1]
            res2 <- prod2[XLEN-n:XLEN*2 -n -1]
            smask1 <- ([signbit1]*XLEN) & ¬m
            smask2 <- ([signbit2]*XLEN) & ¬m
            RT <- (res1 | smask1)
            RS <- (res2 | smask2)

Special Registers Altered:

    None
