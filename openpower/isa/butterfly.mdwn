<!-- SVP64 Butterfly DCT Instructions here described are based on -->

<!-- PLEASE NOTE THESE ARE UNAPPROVED AND DRAFT, NOT SUBMITTED TO OPF ISA WG -->

# [DRAFT] Integer Butterfly Multiply Add/Sub FFT/DCT

A-Form

* maddsubrs  RT,RA,SH,RB

Pseudo-code:

    n <- SH
    sum <- (RT) + (RA)
    diff <- (RT) - (RA)
    prod1 <- MULS(RB, sum)
    prod2 <- MULS(RB, diff)
    if n = 0 then
        prod1_lo <- prod1[XLEN:(XLEN*2) - 1]
        prod2_lo <- prod2[XLEN:(XLEN*2) - 1]
        RT <- prod1_lo
        RS <- prod2_lo
    else
        round <- [0]*(XLEN*2)
        round[XLEN*2 - n] <- 1
        prod1 <- prod1 + round
        prod2 <- prod2 + round
        m <- MASK(XLEN - n - 2, XLEN - 1)
        res1 <- prod1[XLEN - n:XLEN*2 - n - 1]
        res2 <- prod2[XLEN - n:XLEN*2 - n - 1]
        signbit1 <- prod1[0]
        signbit2 <- prod2[0]
        smask1 <- ([signbit1]*XLEN) & ¬m
        smask2 <- ([signbit2]*XLEN) & ¬m
        RT <- (res1 | smask1)
        RS <- (res2 | smask2)

Special Registers Altered:

    None

# [DRAFT] Integer Butterfly Multiply Add and Accumulate FFT/DCT

A-Form

* maddrs  RT,RA,SH,RB

Pseudo-code:

    n <- SH
    prod <- MULS(RB, RA)
    if n = 0 then
        prod_lo <- prod[XLEN:(XLEN*2) - 1]
        RT <- (RT) + prod_lo
        RS <- (RS) - prod_lo
    else
        res1[0:XLEN*2-1] <- (EXTSXL((RT)[0], 1) || (RT)) + prod
        res2[0:XLEN*2-1] <- (EXTSXL((RS)[0], 1) || (RS)) - prod
        round <- [0]*XLEN*2
        round[XLEN*2 - n] <- 1
        res1 <- res1 + round
        res2 <- res2 + round
        signbit1 <- res1[0]
        signbit2 <- res2[0]
        m <- MASK(XLEN -n - 2, XLEN - 1)
        res1 <- res1[XLEN - n:XLEN*2 - n -1]
        res2 <- res2[XLEN - n:XLEN*2 - n -1]
        smask1 <- ([signbit1]*XLEN) & ¬m
        smask2 <- ([signbit2]*XLEN) & ¬m
        RT <- (res1 | smask1)
        RS <- (res2 | smask2)

Special Registers Altered:

    None
