<!-- This defines instructions described in PowerISA Version 3.0 B Book 1 -->

<!-- This defines instructions that load from RAM to a register -->

<!-- Note that these pages also define equivalent store instructions, -->
<!-- these are described in fixedstore.mdwn -->

<!-- Section 3.3.2 This defines the Fixed-Point Load Instructions pages 47 - 53 -->
<!-- Section 3.3.3 Fixed-Point Store Instructions pages 54 - 56 -->
<!-- Section 3.3.3.1 64-bit Fixed-Point Store Instructions pages 57 -->
<!-- Section 3.3.4 Fixed Point Load and Store Quadword Instructions pages 58 - 59 -->
<!-- Section 3.3.5 Fixed-Point Load and Store with Byte Reversal Instructions page 60 -->
<!-- Section 3.3.5.1 64-Bit Load and Store with Byte Reversal Instructions page 61 -->
<!-- Section 3.3.6 Fixed-Point Load and Store Multiple Instructions page 62 -->



<!-- Section 3.3.2 This defines the Fixed-Point Load Instructions pages 47 - 53 -->

<!-- The byte, halfword, word, or doubleword in storage addressed by EA is loaded -->
<!-- into register RT. -->

<!-- Many of the Load instructions have an “update” form, in which register RA is -->
<!-- updated with the effective address. For these forms, if RA!=0 and RA!=RT, the -->
<!-- effective address is placed into register RA and the storage element (byte, -->
<!-- halfword, word, or doubleword) addressed by EA is loaded into RT. -->


# Load Byte and Zero Shifted Indexed

X-Form

* lbzsx RT,RA,RB,SH

Pseudo-code:

    b <- (RA|0)
    EA <- b + (RB) << (SH+1)
    RT <- ([0] * (XLEN-8)) || MEM(EA, 1)

Description:

    Let the effective address (EA) be the sum of the contents of
    register RB shifted by (SH+1), and (RA|0).

    The byte in storage addressed by EA is loaded into RT[56:63].
    RT[0:55] are set to 0.

Special Registers Altered:

    None

# Load Byte and Zero Shifted with Update Indexed

X-Form

* lbzsux RT,RA,RB,SH

Pseudo-code:

    EA <- (RA) + (RB) << (SH+1)
    RT <- ([0] * (XLEN-8)) || MEM(EA, 1)
    RA <- EA

Description:

    Let the effective address (EA) be the sum of the contents of
    register RB shifted by (SH+1), and the contents of register RA.

    The byte in storage addressed by EA is loaded into RT[56:63].
    RT[0:55] are set to 0.

    EA is placed into register RA.

    If RA=0, the instruction form is invalid.

Special Registers Altered:

    None

# Load Halfword and Zero Shifted Indexed

X-Form

* lhzsx RT,RA,RB,SH

Pseudo-code:

    b <- (RA|0)
    EA <- b + (RB) << (SH+1)
    RT <- ([0] * (XLEN-16)) || MEM(EA, 2)

Description:

    Let the effective address (EA) be the sum of the contents of
    register RB shifted by (SH+1), and (RA|0).

    The halfword in storage addressed by EA is loaded into RT[48:63].
    RT[0:47] are set to 0.

Special Registers Altered:

    None

# Load Halfword and Zero Shifted with Update Indexed

X-Form

* lhzsux RT,RA,RB,SH

Pseudo-code:

    EA <- (RA) + (RB) << (SH+1)
    RT <- ([0] * (XLEN-16)) || MEM(EA, 2)
    RA <- EA

Description:

    Let the effective address (EA) be the sum of the contents of
    register RB shifted by (SH+1), and the contents of register RA.

    The halfword in storage addressed by EA is loaded into RT[48:63].
    RT[0:47] are set to 0.

    EA is placed into register RA.

    If RA=0, the instruction form is invalid.

Special Registers Altered:

    None

# Load Halfword Algebraic Shifted Indexed

X-Form

* lhasx RT,RA,RB,SH

Pseudo-code:

    b <- (RA|0)
    EA <- b + (RB) << (SH+1)
    RT <- EXTS(MEM(EA, 2))

Description:

    Let the effective address (EA) be the sum of the contents of
    register RB shifted by (SH+1), and (RA|0).

    The halfword in storage addressed by EA is loaded into RT[48:63].
    RT[0:47] are filled with a copy of bit 0 of the loaded halfword.

Special Registers Altered:

    None

# Load Halfword Algebraic Shifted with Update Indexed

X-Form

* lhasux RT,RA,RB,SH

Pseudo-code:

    EA <- (RA) + (RB) << (SH+1)
    RT <- EXTS(MEM(EA, 2))
    RA <- EA

Description:

    Let the effective address (EA) be the sum of the contents of
    register RB shifted by (SH+1), and the contents of register RA.

    The halfword in storage addressed by EA is loaded into RT[48:63].
    RT[0:47] are filled with a copy of bit 0 of the loaded halfword.

    EA is placed into register RA.

    If RA=0 or RA=RT, the instruction form is invalid.

Special Registers Altered:

    None

# Load Word and Zero Shifted Indexed

X-Form

* lwzsx RT,RA,RB,SH

Pseudo-code:

    b <- (RA|0)
    EA <- b + (RB) << (SH+1)
    RT <- [0] * 32 || MEM(EA, 4)

Description:

    Let the effective address (EA) be the sum of the contents of
    register RB shifted by (SH+1), and (RA|0).

    The word in storage addressed by EA is loaded into RT[32:63].
    RT[0:31] are set to 0.

Special Registers Altered:

    None

# Load Word and Zero Shifted with Update Indexed

X-Form

* lwzsux RT,RA,RB,SH

Pseudo-code:

    EA <- (RA) + (RB) << (SH+1)
    RT <- [0] * 32 || MEM(EA, 4)
    RA <- EA

Description:

    Let the effective address (EA) be the sum of the contents of
    register RB shifted by (SH+1), and the contents of register RA.

    The word in storage addressed by EA is loaded into RT[32:63].
    RT[0:31] are set to 0.

    EA is placed into register RA.

    If RA=0 or RA=RT, the instruction form is invalid.

Special Registers Altered:

    None

# Load Word Algebraic Shifted Indexed

X-Form

* lwasx RT,RA,RB,SH

Pseudo-code:

    b <- (RA|0)
    EA <- b + (RB) << (SH+1)
    RT <- EXTS(MEM(EA, 4))

Description:

    Let the effective address (EA) be the sum of the contents of
    register RB shifted by (SH+1), and (RA|0).

    The word in storage addressed by EA is loaded into RT[32:63].
    RT[0:31] are filled with a copy of bit 0 of the loaded word.

Special Registers Altered:

    None

# Load Word Algebraic Shifted with Update Indexed

X-Form

* lwasux RT,RA,RB,SH

Pseudo-code:

    EA <- (RA) + (RB) << (SH+1)
    RT <- EXTS(MEM(EA, 4))
    RA <- EA

Description:

    Let the effective address (EA) be the sum of the contents of
    register RB shifted by (SH+1), and (RA).

    The word in storage addressed by EA is loaded into RT[32:63].
    RT[0:31] are filled with a copy of bit 0 of the loaded word.

    EA is placed into register RA.

    If RA=0 or RA=RT, the instruction form is invalid.

Special Registers Altered:

    None

# Load Doubleword Shifted Indexed

X-Form

* ldsx RT,RA,RB,SH

Pseudo-code:

    b <- (RA|0)
    EA <- b + (RB) << (SH+1)
    RT <- MEM(EA, 8)

Description:

    Let the effective address (EA) be the sum of the contents of
    register RB shifted by (SH+1), and (RA|0).

    The doubleword in storage addressed by EA is loaded into RT.

Special Registers Altered:

    None

# Load Doubleword Shifted with Update Indexed

X-Form

* ldsux RT,RA,RB,SH

Pseudo-code:

    EA <- (RA) + (RB) << (SH+1)
    RT <- MEM(EA, 8)
    RA <- EA

Special Registers Altered:

    None

<!-- byte-reverse shifted -->

# Load Halfword Byte-Reverse Shifted Indexed

X-Form

* lhbrsx RT,RA,RB,SH

Pseudo-code:

    b <- (RA|0)
    EA <- b + (RB) << (SH+1)
    load_data <- MEM(EA, 2)
    RT <- [0]*48 || load_data[8:15] || load_data[0:7]

Description:

    Let the effective address (EA) be the sum of the contents of
    register RB shifted by (SH+1), and (RA|0).

    The doubleword in storage addressed by EA is loaded into RT.

    EA is placed into register RA.

    If RA=0 or RA=RT, the instruction form is invalid.


Special Registers Altered:

    None

# Load Word Byte-Reverse Shifted Indexed

X-Form

* lwbrsx RT,RA,RB,SH

Pseudo-code:

    b <- (RA|0)
    EA <- b + (RB) << (SH+1)
    load_data <- MEM(EA, 4)
    RT <- ([0] * 32 || load_data[24:31] || load_data[16:23]
                    || load_data[8:15]  || load_data[0:7])

Description:

    Let the effective address (EA) be the sum of the contents of
    register RB shifted by (SH+1), and (RA|0).

    Bits 0:7 of the word in storage addressed
    by EA are loaded into RT[56:63]. Bits 8:15 of the word in
    storage addressed by EA are loaded into RT[48:55]. Bits
    16:23 of the word in storage addressed by EA are
    loaded into RT[40:47]. Bits 24:31 of the word in storage
    addressed by EA are loaded into RT 32:39.
    RT[0:31] are set to 0.

Special Registers Altered:

    None


<!-- Section 3.3.5.1 64-Bit Load and Store with Byte Reversal Instructions page 61 -->

# Load Doubleword Byte-Reverse Shifted Indexed

X-Form

* ldbrsx RT,RA,RB,SH

Pseudo-code:

    b <- (RA|0)
    EA <- b + (RB) << (SH+1)
    load_data <- MEM(EA, 8)
    RT <- (load_data[56:63] || load_data[48:55]
        || load_data[40:47] || load_data[32:39]
        || load_data[24:31] || load_data[16:23]
        || load_data[8:15]  || load_data[0:7])

Description:

    Let the effective address (EA) be the sum of the contents of
    register RB shifted by (SH+1), and (RA|0).

    Bits 0:7 of the doubleword in storage addressed by EA
    are loaded into RT[56:63]. Bits 8:15 of the doubleword in
    storage addressed by EA are loaded into RT[48:55]. Bits
    16:23 of the doubleword in storage addressed by EA
    are loaded into RT[40:47]. Bits 24:31 of the doubleword in
    storage addressed by EA are loaded into RT 32:39. Bits
    32:39 of the doubleword in storage addressed by EA
    are loaded into RT[24:31]. Bits 40:47 of the doubleword in
    storage addressed by EA are loaded into RT[16:23]. Bits
    48:55 of the doubleword in storage addressed by EA
    are loaded into RT[8:15]. Bits 56:63 of the doubleword in
    storage addressed by EA are loaded into RT[0:7].


Special Registers Altered:

    None

