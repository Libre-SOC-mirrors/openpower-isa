# A.3 Floating-Point Convert from Integer Model

The following describes algorithmically the operation of the Floating
Convert From Integer instructions.

<!-- Power ISA Book I Version 3.0B Section A.3 page 782 -->

    def INT2FP(FR, cvt, RN):
        if cvt = "sint2double" then
            tgt_precision = "double-precision"
            sign       <- FR[0]
        if cvt = "sint2single" then
            tgt_precision <- "single-precision"
            sign       <- FR[0]
        if cvt = "uint2double" then
            tgt_precision <- "double-precision"
            sign       <- 0
        if cvt = "uint2single" then
            tgt_precision <- "single-precision"
            sign       <- 0

        result = [0] * 64
        exp        <- 63
        frac[0:63] <- FR

        if frac[0:63] = 0 then
            # Zero Operand
            FPSCR[FR] <- 0b00
            FPSCR[FI] <- 0b00
            FPSCR[FPRF] <- "+ zero"
        else
            if sign = 1 then frac[0:63] <- Â¬frac[0:63] + 1
            # do the loop 0 times if FR = max negative 64-bit integer or
            #                     if FR = max unsigned 64-bit integer 
            do while frac[0] = 0
                frac[0:63] <- frac[1:63] || 0b0
                exp <- exp - 1
            Round_Float( tgt_precision, sign, exp, frac0:63, RN )
            if sign = 0 then FPSCR[FPRF] <- "+normal number"
            if sign = 1 then FPSCR[FPRF] <- "-normal number"
            result[0]    <- sign
            result[1:11] <- exp + 1023     # exp + bias
            result[12:63] <- frac[1:52]

        return result

